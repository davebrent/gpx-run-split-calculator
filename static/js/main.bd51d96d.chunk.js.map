{"version":3,"sources":["gpx.js","components/FileDropper.js","running.js","App.js","index.js"],"names":["gpxParser","this","xmlSource","metadata","waypoints","tracks","routes","prototype","parse","gpxstring","domParser","window","DOMParser","parseFromString","querySelector","name","getElementValue","desc","time","author","authorElem","email","emailElem","id","getAttribute","domain","link","linkElem","href","text","type","queryDirectSelector","wpts","slice","call","querySelectorAll","idx","wpt","pt","lat","parseFloat","lon","ele","cmt","push","rtes","rte","route","src","number","innerHTML","routepoints","rtepts","idxIn","rtept","distance","calculDistance","elevation","calcElevation","points","trks","trk","track","trackpoints","trkpts","trkpt","parent","needle","elem","undefined","childNodes","data","elements","finalElem","length","directChilds","tagName","totalDistance","cumulDistance","i","calcDistanceBetween","total","cumul","wpt1","wpt2","latlng1","latlng2","rad","Math","PI","lat1","lat2","sinDLat","sin","sinDLon","a","cos","atan2","sqrt","dp","dm","ret","diff","sum","k","len","max","apply","min","pos","abs","neg","avg","toGeoJSON","GeoJSON","feature","properties","geoPt","geometry","coordinates","features","FileDroppper","event","preventDefault","props","onFilesDrop","dataTransfer","files","className","onDrop","handleDrop","onDragOver","handleDragOver","children","React","Component","ONE_MILE","toKms","FIVE_MILE","TEN_MILE","miles","fractionOver","previous","target","over","fromGpx","output","elapsed","map","point","turfPoint","Date","current","turfDistance","units","splits","multiple","tolerance","prevDistance","targetDistance","overDistance","prevTime","overTime","previousTime","first","last","t","d","estimated","shortBy","benchmarkDistances","oneKs","oneMiles","fiveKs","fiveMiles","tenKs","tenMiles","halfMarathons","marathons","fiftyKs","App","state","active","file","reader","FileReader","readAsText","onload","gpx","GpxParser","result","err","error","extra","Object","assign","setState","prefix","key","onClick","handleFileClick","header","hasEstimate","filter","split","s","secs","mins","hrs","toString","padStart","msToTime","toFixed","renderEstimate","renderSplitsForDistance","activeFile","handleFiles","renderFile","renderActiveFile","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.bd51d96d.chunk.js","sourcesContent":["// Taken and adapted from 'gpxparser' package\n\n/**\n * GPX file parser\n * \n * @constructor\n */\nvar gpxParser = function () {\n    this.xmlSource = \"\";\n    this.metadata  = {};\n    this.waypoints = [];\n    this.tracks    = [];\n    this.routes    = [];\n};\n\n/**\n * Parse a gpx formatted string to a GPXParser Object\n * \n * @param {string} gpxstring - A GPX formatted String\n * \n * @return {gpxParser} A GPXParser object\n */\ngpxParser.prototype.parse = function (gpxstring) {\n    var keepThis = this;\n    var domParser = new window.DOMParser();\n    this.xmlSource = domParser.parseFromString(gpxstring, 'text/xml');\n\n    var metadata = this.xmlSource.querySelector('metadata');\n    if(metadata != null){\n        this.metadata.name  = this.getElementValue(metadata, \"name\");\n        this.metadata.desc  = this.getElementValue(metadata, \"desc\");\n        this.metadata.time  = this.getElementValue(metadata, \"time\");\n\n        let author = {};\n        let authorElem = metadata.querySelector('author');\n        if(authorElem != null){\n            author.name = this.getElementValue(authorElem, \"name\");\n            author.email  = {};\n            let emailElem = authorElem.querySelector('email');\n            if(emailElem != null){\n                author.email.id     = emailElem.getAttribute(\"id\");\n                author.email.domain = emailElem.getAttribute(\"domain\");\n            }\n\n            let link     = {};\n            let linkElem = authorElem.querySelector('link');\n            if(linkElem != null){\n                link.href = linkElem.getAttribute('href');\n                link.text = this.getElementValue(linkElem, \"text\");\n                link.type = this.getElementValue(linkElem, \"type\");\n            }\n            author.link = link;\n        }\n        this.metadata.author = author;\n\n        let link = {};\n        let linkElem = this.queryDirectSelector(metadata, 'link');\n        if(linkElem != null){\n            link.href = linkElem.getAttribute('href');\n            link.text = this.getElementValue(linkElem, \"text\");\n            link.type = this.getElementValue(linkElem, \"type\");\n            this.metadata.link = link;\n        }\n    }\n\n    var wpts = [].slice.call(this.xmlSource.querySelectorAll('wpt'));\n    for (let idx in wpts){\n        var wpt = wpts[idx];\n        let pt  = {};\n        pt.name = keepThis.getElementValue(wpt, \"name\")\n        pt.lat  = parseFloat(wpt.getAttribute(\"lat\"));\n        pt.lon  = parseFloat(wpt.getAttribute(\"lon\"));\n        pt.ele  = parseFloat(keepThis.getElementValue(wpt, \"ele\")) || null;\n        pt.cmt  = keepThis.getElementValue(wpt, \"cmt\");\n        pt.desc = keepThis.getElementValue(wpt, \"desc\");\n        keepThis.waypoints.push(pt);\n    }\n\n    var rtes = [].slice.call(this.xmlSource.querySelectorAll('rte'));\n    for (let idx in rtes){\n        var rte = rtes[idx];\n        let route = {};\n        route.name   = keepThis.getElementValue(rte, \"name\");\n        route.cmt    = keepThis.getElementValue(rte, \"cmt\");\n        route.desc   = keepThis.getElementValue(rte, \"desc\");\n        route.src    = keepThis.getElementValue(rte, \"src\");\n        route.number = keepThis.getElementValue(rte, \"number\");\n\n        let type     = keepThis.queryDirectSelector(rte, \"type\");\n        route.type   = type != null ? type.innerHTML : null;\n\n        let link     = {};\n        let linkElem = rte.querySelector('link');\n        if(linkElem != null){\n            link.href = linkElem.getAttribute('href');\n            link.text = keepThis.getElementValue(linkElem, \"text\");\n            link.type = keepThis.getElementValue(linkElem, \"type\");\n        }\n        route.link = link;\n\n        let routepoints = [];\n        var rtepts = [].slice.call(rte.querySelectorAll('rtept'));\n\n        for (let idxIn in rtepts){\n            var rtept = rtepts[idxIn];\n            let pt    = {};\n            pt.lat    = parseFloat(rtept.getAttribute(\"lat\"));\n            pt.lon    = parseFloat(rtept.getAttribute(\"lon\"));\n            pt.ele    = parseFloat(keepThis.getElementValue(rtept, \"ele\"));\n            pt.time    = parseFloat(rtept.getAttribute(\"time\"));\n            routepoints.push(pt);\n        }\n\n        route.distance = keepThis.calculDistance(routepoints);\n        route.elevation = keepThis.calcElevation(routepoints);\n        route.points = routepoints;\n        keepThis.routes.push(route);\n    }\n\n    var trks = [].slice.call(this.xmlSource.querySelectorAll('trk'));\n    for (let idx in trks){\n        var trk = trks[idx];\n        let track = {};\n\n        track.name   = keepThis.getElementValue(trk, \"name\");\n        track.cmt    = keepThis.getElementValue(trk, \"cmt\");\n        track.desc   = keepThis.getElementValue(trk, \"desc\");\n        track.src    = keepThis.getElementValue(trk, \"src\");\n        track.number = keepThis.getElementValue(trk, \"number\");\n\n        let type     = keepThis.queryDirectSelector(trk, \"type\");\n        track.type   = type != null ? type.innerHTML : null;\n\n        let link     = {};\n        let linkElem = trk.querySelector('link');\n        if(linkElem != null){\n            link.href = linkElem.getAttribute('href');\n            link.text = keepThis.getElementValue(linkElem, \"text\");\n            link.type = keepThis.getElementValue(linkElem, \"type\");\n        }\n        track.link = link;\n\n        let trackpoints = [];\n        var trkpts = [].slice.call(trk.querySelectorAll('trkpt'));\n\t    for (let idxIn in trkpts){\n            var trkpt = trkpts[idxIn];\n            let pt = {};\n            pt.lat = parseFloat(trkpt.getAttribute(\"lat\"));\n            pt.lon = parseFloat(trkpt.getAttribute(\"lon\"));\n            pt.ele = parseFloat(keepThis.getElementValue(trkpt, \"ele\")) || null;\n            pt.time = keepThis.getElementValue(trkpt, \"time\") || null;\n            trackpoints.push(pt);\n        }\n        track.distance = keepThis.calculDistance(trackpoints);\n        track.elevation = keepThis.calcElevation(trackpoints);\n        track.points = trackpoints;\n\n        keepThis.tracks.push(track);\n    }\n};\n\n/**\n * Get value from a XML DOM element\n * \n * @param  {Element} parent - Parent DOM Element\n * @param  {string} needle - Name of the searched element\n * \n * @return {} The element value\n */\ngpxParser.prototype.getElementValue = function(parent, needle){\n    let elem = parent.querySelector(needle);\n    if(elem != null){\n        return elem.innerHTML !== undefined ? elem.innerHTML : elem.childNodes[0].data;\n    }\n    return elem;\n}\n\n\n/**\n * Search the value of a direct child XML DOM element\n * \n * @param  {Element} parent - Parent DOM Element\n * @param  {string} needle - Name of the searched element\n * \n * @return {} The element value\n */\ngpxParser.prototype.queryDirectSelector = function(parent, needle) {\n\n    let elements  = parent.querySelectorAll(needle);\n    let finalElem = elements[0];\n\n    if(elements.length > 1) {\n        let directChilds = parent.childNodes;\n\n        for(var idx in directChilds) {\n            var elem = directChilds[idx];\n            if(elem.tagName === needle) {\n                finalElem = elem;\n            }\n        }\n    }\n\n    return finalElem;\n}\n\n/**\n * Calcul the Distance Object from an array of points\n * \n * @param  {} points - An array of points with lat and lon properties\n * \n * @return {DistanceObject} An object with total distance and Cumulative distances\n */\ngpxParser.prototype.calculDistance = function(points) {\n    let distance = {};\n    let totalDistance = 0;\n    let cumulDistance = [];\n    for (var i = 0; i < points.length - 1; i++) {\n        totalDistance += this.calcDistanceBetween(points[i],points[i+1]);\n        cumulDistance[i] = totalDistance;\n    }\n    cumulDistance[points.length - 1] = totalDistance;\n\n    distance.total = totalDistance;\n    distance.cumul = cumulDistance;\n\n    return distance;\n}\n/**\n * Calcul Distance between two points with lat and lon\n * \n * @param  {} wpt1 - A geographic point with lat and lon properties\n * @param  {} wpt2 - A geographic point with lat and lon properties\n * \n * @returns {float} The distance between the two points\n */\ngpxParser.prototype.calcDistanceBetween = function (wpt1, wpt2) {\n    let latlng1 = {};\n    latlng1.lat = wpt1.lat;\n    latlng1.lon = wpt1.lon;\n    let latlng2 = {};\n    latlng2.lat = wpt2.lat;\n    latlng2.lon = wpt2.lon;\n    var rad = Math.PI / 180,\n\t\t    lat1 = latlng1.lat * rad,\n\t\t    lat2 = latlng2.lat * rad,\n\t\t    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),\n\t\t    sinDLon = Math.sin((latlng2.lon - latlng1.lon) * rad / 2),\n\t\t    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,\n\t\t    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\treturn 6371000 * c;\n}\n\n/**\n * Generate Elevation Object from an array of points\n * \n * @param  {} points - An array of points with ele property\n * \n * @returns {ElevationObject} An object with negative and positive height difference and average, max and min altitude data\n */\ngpxParser.prototype.calcElevation = function (points) {\n    var dp = 0,\n        dm = 0,\n        ret = {};\n\n    for (var i = 0; i < points.length - 1; i++) {\n        var diff = parseFloat(points[i + 1].ele) - parseFloat(points[i].ele);\n\n        if (diff < 0) {\n            dm += diff;\n        } else if (diff > 0) {\n            dp += diff;\n        }\n    }\n\n    var elevation = [];\n    var sum = 0;\n\n    for (var k = 0, len = points.length; k < len; k++) {\n        var ele = parseFloat(points[k].ele);\n        elevation.push(ele);\n        sum += ele;\n    }\n\n    ret.max = Math.max.apply(null, elevation) || null;\n    ret.min = Math.min.apply(null, elevation) || null;\n    ret.pos = Math.abs(dp) || null;\n    ret.neg = Math.abs(dm) || null;\n    ret.avg = sum / elevation.length || null;\n\n    return ret;\n};\n\n/**\n * Export the GPX object to a GeoJSON formatted Object\n * \n * @returns {} a GeoJSON formatted Object\n */\ngpxParser.prototype.toGeoJSON = function () {\n    var GeoJSON = {\n        \"type\": \"FeatureCollection\",\n        \"features\": [],\n        \"properties\": {\n            \"name\": this.metadata.name,\n            \"desc\": this.metadata.desc,\n            \"time\": this.metadata.time,\n            \"author\": this.metadata.author,\n            \"link\": this.metadata.link,\n        },\n    };\n\n    for(var idx in this.tracks) {\n        let track = this.tracks[idx];\n\n        var feature = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": []\n            },\n            \"properties\": {\n            }\n        };\n\n        feature.properties.name   = track.name;\n        feature.properties.cmt    = track.cmt;\n        feature.properties.desc   = track.desc;\n        feature.properties.src    = track.src;\n        feature.properties.number = track.number;\n        feature.properties.link   = track.link;\n        feature.properties.type   = track.type;\n\n        for(idx in track.points) {\n            let pt = track.points[idx];\n        \n            var geoPt = [];\n            geoPt.push(pt.lon);\n            geoPt.push(pt.lat);\n            geoPt.push(pt.ele);\n\n            feature.geometry.coordinates.push(geoPt);\n        }\n\n        GeoJSON.features.push(feature);\n    }\n\n    for(idx in this.routes) {\n        let track = this.routes[idx];\n\n        feature = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": []\n            },\n            \"properties\": {\n            }\n        };\n\n        feature.properties.name   = track.name;\n        feature.properties.cmt    = track.cmt;\n        feature.properties.desc   = track.desc;\n        feature.properties.src    = track.src;\n        feature.properties.number = track.number;\n        feature.properties.link   = track.link;\n        feature.properties.type   = track.type;\n\n\n        for(idx in track.points) {\n            let pt = track.points[idx];\n        \n            geoPt = [];\n            geoPt.push(pt.lon);\n            geoPt.push(pt.lat);\n            geoPt.push(pt.ele);\n\n            feature.geometry.coordinates.push(geoPt);\n        }\n\n        GeoJSON.features.push(feature);\n    }\n\n    for(idx in this.waypoints) {\n        let pt = this.waypoints[idx];\n    \n        feature = {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": []\n            },\n            \"properties\": {\n            }\n        };\n\n        feature.properties.name = pt.name;\n        feature.properties.cmt  = pt.cmt;\n        feature.properties.desc = pt.desc;\n\n        feature.geometry.coordinates = [pt.lon, pt.lat, pt.ele];\n\n        GeoJSON.features.push(feature);\n    }\n\n    return GeoJSON;\n}\n\nexport default gpxParser;\n","import React from 'react';\n\nimport './FileDropper.css';\n\nexport default class FileDroppper extends React.Component {\n  handleDrop(event) {\n    event.preventDefault();\n    this.props.onFilesDrop(event.dataTransfer.files);\n  }\n\n  handleDragOver(event) {\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <div\n        className=\"filedropper\"\n        onDrop={event => this.handleDrop(event)}\n        onDragOver={event => this.handleDragOver(event)}\n      >\n        <div className=\"filedropper__text\">\n          {this.props.children}\n        </div>\n      </div>\n    );\n  }\n}\n","import turfDistance from \"@turf/distance\";\nimport { point as turfPoint } from \"@turf/helpers\";\n\n// Are some popular web platforms calculating the distances for their \"Best\n// Efforts\" feature from rounded imperial distances converted to metric?\nconst ONE_K = 1;\nconst ONE_MILE = toKms(1);\nconst FIVE_K = 5; // toKms(3.1);\nconst FIVE_MILE = toKms(5);\nconst TEN_K = 10; // toKms(6.2);\nconst TEN_MILE = toKms(10);\nconst HALF_MARATHON = 21.0975; // toKms(13.1);\nconst MARATHON = 42.195; // toKms(26.2);\nconst FIFTY_K = 50;\n\nfunction toKms (miles) {\n  return miles * 1.60934;\n}\n\nfunction fractionOver (previous, target, over) {\n  const d = over - previous;\n  const n = target - previous;\n  return n / d;\n}\n\nfunction lerpTime (prevDistance, targetDistance, overDistance, prevTime, overTime) {\n  const t = fractionOver(prevDistance, targetDistance, overDistance);\n  const diff = overTime - prevTime;\n  return prevTime + diff * t;\n}\n\n/// Transform GPX points into a simpler list of distance,time,elevation points.\nexport function fromGpx (points) {\n  points = points.map(({ lon, lat, ele, time }) => {\n    return {\n      point: turfPoint([lon, lat]),\n      time: Date.parse(time),\n      elevation: ele,\n    }\n  });\n\n  const output = [];\n\n  let elapsed = 0;\n  let previous = points[0];\n  for (const current of points) {\n    const time = current.time - points[0].time;\n    elapsed += turfDistance(previous.point, current.point, {\n      units: \"kilometers\",\n    });\n    output.push({\n      distance: elapsed,\n      elevation: current.elevation,\n      time: time,\n    });\n    previous = current;\n  }\n\n  return output;\n}\n\n/// Calculate the splits using a given multiple\nexport function splits (points, multiple, tolerance) {\n  const output = [];\n\n  let distance = multiple;\n  let previous = points[0];\n  let previousTime = 0;\n  let elevation = 0;\n\n  for (const current of points) {\n    elevation += current.elevation - previous.elevation;\n    if (current.distance < distance) {\n      previous = current;\n      continue;\n    }\n\n    const time = lerpTime(\n      previous.distance,\n      distance,\n      current.distance,\n      previous.time,\n      current.time\n    );\n\n    output.push({\n      time: time - previousTime,\n      elevation,\n    });\n\n    elevation = 0;\n    distance += multiple;\n    previousTime = time;\n    previous = current;\n  }\n\n  const first = points[0];\n  const last = points[points.length - 1];\n\n  if (last.distance >= distance - tolerance) {\n    const t = fractionOver(first.distance, last.distance, distance);\n    const d = 1 + ((1 - t) / t);\n\n    const diff = last.time - first.time;\n    const time = first.time + diff * d;\n\n    output.push({\n      time: time - previousTime,\n      elevation,\n      estimated: true,\n      shortBy: (distance - last.distance) * 1000,\n    });\n  }\n\n  return output;\n}\n\n/// Calculate splits using common benchmark distances as a multiple\nexport function benchmarkDistances (points) {\n  return {\n    oneKs: splits(points, ONE_K, 0.05),\n    oneMiles: splits(points, ONE_MILE, 0.05),\n    fiveKs: splits(points, FIVE_K, 0.05),\n    fiveMiles: splits(points, FIVE_MILE, 0.05),\n    tenKs: splits(points, TEN_K, 0.05),\n    tenMiles: splits(points, TEN_MILE, 0.05),\n    halfMarathons: splits(points, HALF_MARATHON, 0.05),\n    marathons: splits(points, MARATHON, 0.05),\n    fiftyKs: splits(points, FIFTY_K, 0.05),\n  };\n}\n","import React from \"react\";\nimport GpxParser from \"./gpx\";\n\nimport \"./App.css\";\nimport FileDropper from \"./components/FileDropper.js\";\nimport { fromGpx, benchmarkDistances } from \"./running.js\";\n\nfunction msToTime(s) {\n  var ms = s % 1000;\n  s = (s - ms) / 1000;\n  var secs = s % 60;\n  s = (s - secs) / 60;\n  var mins = s % 60;\n  var hrs = (s - mins) / 60;\n\n  hrs = hrs.toString().padStart(2, '0');\n  mins = mins.toString().padStart(2, '0');\n  secs = secs.toString().padStart(2, '0');\n  return hrs + ':' + mins + ':' + secs;\n}\n\nexport default class App extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      active: null,\n      files: [],\n    };\n  }\n\n  handleFiles(files) {\n    const active = this.state.files.length;\n\n    for (const file of files) {\n      var reader = new FileReader();\n      reader.readAsText(file, \"utf-8\");\n      reader.onload = async (event) => {\n        const gpx = new GpxParser()\n        try {\n          gpx.parse(event.target.result);\n        } catch (err) {}\n\n        var data = {\n          name: file.name,\n          error: false,\n        }\n\n        if (gpx.tracks.length >= 1) {\n          const points = fromGpx(gpx.tracks[0].points);\n          const extra = benchmarkDistances(points);\n\n          data = Object.assign({}, data, extra);\n        } else {\n          data.error = true;\n        }\n\n        this.setState(state => {\n          return Object.assign({}, state, {\n            files: [...state.files, data],\n            active: active,\n          })\n        });\n      };\n    }\n  }\n\n  handleFileClick(i) {\n    this.setState(state => {\n      return { active: i };\n    });\n  }\n\n  renderFile(data, i) {\n    const { active } = this.state;\n    const prefix = 'app__sidebar__file';\n    return (\n      <button\n        className={`${prefix} ${i === active ? prefix + '--active' : ''}`}\n        key={`${data.name}-${i}`}\n        onClick={event => this.handleFileClick(i)}\n      >\n        {data.name}\n      </button>\n    );\n  }\n\n  renderSplitsForDistance(header, splits) {\n    if (splits.length === 0) {\n      return;\n    }\n\n    const renderEstimate = (split) => {\n      if (!split.estimated) {\n        return;\n      }\n      return (\n        <span className=\"estimate\">{`${split.shortBy.toFixed(2)} meters`}</span>\n      );\n    };\n\n    const hasEstimate = splits\n      .filter(split => split.estimated === true)\n      .length !== 0;\n\n    return (\n      <div className=\"distance\">\n        <h3 className=\"distance__header\">{header}</h3>\n        <table className=\"distance__table\">\n          <thead>\n            <tr>\n              <th></th>\n              <th>Time</th>\n              {hasEstimate && (<th>Estimated</th>)}\n              <th className=\"ralign\">Elevation(m)</th>\n            </tr>\n          </thead>\n          <tbody>\n            {splits.map((split, i) => {\n              return (\n                <tr key={i}>\n                  <td>{i + 1}</td>\n                  <td>{msToTime(split.time)}</td>\n                  {hasEstimate && <td>{renderEstimate(split)}</td>}\n                  <td className=\"ralign\">{split.elevation.toFixed(2)}</td>\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n\n  renderActiveFile(data) {\n    const withError = () => (\n      <p className=\"file__distances\">\n        File does not contain any tracks\n      </p>\n    );\n\n    const withData = () => (\n      <div className=\"file__distances\">\n        {/* this.renderSplitsForDistance(\"1k\", data.oneKs) */}\n        {this.renderSplitsForDistance(\"1M\", data.oneMiles)}\n        {this.renderSplitsForDistance(\"5k\", data.fiveKs)}\n        {/* this.renderSplitsForDistance(\"5M\", data.fiveMiles) */}\n        {this.renderSplitsForDistance(\"10k\", data.tenKs)}\n        {/* this.renderSplitsForDistance(\"10M\", data.tenMiles) */}\n        {this.renderSplitsForDistance(\"Half Marathon\", data.halfMarathons)}\n        {this.renderSplitsForDistance(\"Marathon\", data.marathons)}\n        {this.renderSplitsForDistance(\"50k\", data.fiftyKs)}\n      </div>\n    );\n\n    return (\n      <div className=\"file\">\n        <h2 className=\"file__name\">{data.name}</h2>\n        {data.error === true ? withError() : withData()}\n      </div>\n    );\n  }\n\n  render() {\n    const { files, active } = this.state;\n    const activeFile = files[active];\n    return (\n      <div className=\"app\">\n        <div className=\"app__sidebar\">\n          <FileDropper onFilesDrop={files => this.handleFiles(files)}>\n            Drop GPX files here\n          </FileDropper>\n          {files.map((file, i) => this.renderFile(file, i))}\n        </div>\n        <div className=\"app__content\">\n          {activeFile && this.renderActiveFile(activeFile)} \n        </div>\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport 'normalize.css/normalize.css';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}